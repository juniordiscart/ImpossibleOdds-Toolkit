namespace ImpossibleOdds.Photon.WebRpc
{
	using System;
	using System.Collections.Generic;
	using System.Reflection;
	using ImpossibleOdds.Http;
	using ImpossibleOdds.Weblink;
	using ImpossibleOdds.Serialization;
	using global::Photon.Realtime;
	using ExitGames.Client.Photon;

	/// <summary>
	/// A messenger for WebRPC calls sent over the Photon multiplayer package.
	/// Implements the IWebRpcCallback interface so that it can be registered in the Photon callback targets.
	/// </summary>
	public class WebRpcMessenger :
		WeblinkMessenger<IWebRpcRequest, IWebRpcResponse, WebRpcMessageHandle, WebRpcResponseTypeAttribute, WebRpcResponseCallbackAttribute>,
		IWebRpcCallback,
		IDisposable
	{
		public const ushort MinimumIDLength = 4;
		public const ushort DefaultIDLength = 8;
		public const string DefaultRequestIDKey = "RequestId";
		public const string DefaultResponseIDKey = "ResponseId";
		private const string IDGenerationPool = "ABCDEFGHIJKLMNPQRSTUVWXYabcdefghjklmnopqrstuvwxyz0123456789_-";

		private readonly static WebRpcBodySerializationDefinition bodyDefinition = new WebRpcBodySerializationDefinition();
		private readonly static WebRpcUrlSerializationDefinition urlDefinition = new WebRpcUrlSerializationDefinition();

		private readonly LoadBalancingClient photonClient = null;
		private ushort generatedIDLength = DefaultIDLength;
		private string requestIDKey = DefaultRequestIDKey;
		private string responseIDKey = DefaultResponseIDKey;
		private Dictionary<string, WebRpcMessageHandle> pendingCalls = new Dictionary<string, WebRpcMessageHandle>();

		/// <summary>
		/// The key of the Request ID that gets added to each outgoing WebRPC call to match incoming responses.
		/// </summary>
		public string RequestIDKey
		{
			get { return requestIDKey; }
			set
			{
				value.ThrowIfNullOrWhitespace(nameof(value));

				if ((pendingCalls.Count > 0) && (value != requestIDKey))
				{
					Log.Warning("A different name for the request ID key is being set while there are still pending calls. Incoming responses for the remaining pending calls will not be matched anymore. These will be cancelled.");
					StopAll();
				}

				requestIDKey = value;
			}
		}

		/// <summary>
		/// The key of the Response ID that should be set by the server for each response.
		/// </summary>
		public string ResponseIDKey
		{
			get { return responseIDKey; }
			set
			{
				value.ThrowIfNullOrWhitespace(nameof(value));

				if ((pendingCalls.Count > 0) && (value != responseIDKey))
				{
					Log.Warning("A different name for the response ID key is being set while there are still pending calls. Incoming responses for the remaining pending calls will not be matched anymore. These will be cancelled.");
					StopAll();
				}

				responseIDKey = value;
			}
		}

		/// <summary>
		/// The length of the IDs generated by the messenger.
		/// </summary>
		public ushort GeneratedIDLength
		{
			get { return generatedIDLength; }
			set
			{
				if (value < MinimumIDLength)
				{
					throw new ArgumentOutOfRangeException(string.Format("The length of IDs should at least be {0} long as to prevent collision.", MinimumIDLength));
				}

				generatedIDLength = value;
			}
		}

		public WebRpcMessenger(LoadBalancingClient photonClient)
		{
			photonClient.ThrowIfNull(nameof(photonClient));
			this.photonClient = photonClient;
			photonClient.AddCallbackTarget(this);
		}

		/// <summary>
		/// Clears the messenger from the photon client.
		/// </summary>
		public void Dispose()
		{
			photonClient.RemoveCallbackTarget(this);
		}

		/// <inheritdoc />
		public override WebRpcMessageHandle SendRequest(IWebRpcRequest request)
		{
			request.ThrowIfNull(nameof(request));

			if (!photonClient.IsConnectedAndReady)
			{
				throw new WebRpcException("Photon isn't connected. Cannot send out any requests.");
			}

			// If the request is already pending, just return the existing handle.
			if (IsPending(request))
			{
				return GetMessageHandle(request);
			}

			return CustomOpWebRPC(request, GenerateRequestUriPath(request), GenerateRequestBody(request));
		}

		/// <inheritdoc />
		public override void StopAll()
		{
			base.StopAll();
			pendingCalls.Clear();
		}

		/// <summary>
		/// Stops a pending request with the given ID.
		/// </summary>
		/// <param name="requestID">The ID of the request to stop.</param>
		public void Stop(string requestID)
		{
			requestID.ThrowIfNullOrWhitespace(nameof(requestID));

			if (IsPending(requestID))
			{
				RemovePendingRequest(pendingCalls[requestID]);
			}
		}

		/// <summary>
		/// Check whether a request with the given request ID is pending a response.
		/// </summary>
		/// <param name="requestID">The ID of the request to check for.</param>
		/// <returns>True if such a request is pending. False otherwise.</returns>
		public bool IsPending(string requestID)
		{
			requestID.ThrowIfNullOrWhitespace(nameof(requestID));
			return pendingCalls.ContainsKey(requestID);
		}

		/// <inheritdoc />
		protected override void AddPendingRequest(WebRpcMessageHandle handle)
		{
			handle.ThrowIfNull(nameof(handle));

			base.AddPendingRequest(handle);
			pendingCalls[handle.RequestID] = handle;
		}

		/// <inheritdoc />
		protected override void RemovePendingRequest(IWebRpcRequest request)
		{
			request.ThrowIfNull(nameof(request));

			if (IsPending(request))
			{
				WebRpcMessageHandle handle = GetMessageHandle(request);
				pendingCalls.Remove(handle.RequestID);
			}

			base.RemovePendingRequest(request);
		}

		/// <summary>
		/// Generates the URI of the request.
		/// </summary>
		/// <param name="request">The request to be sent.</param>
		/// <returns>The URI of the request, appended with any parameters as defined by the request, if any.</returns>
		private string GenerateRequestUriPath(IWebRpcRequest request)
		{
			request.ThrowIfNull(nameof(request));

			string requestUri = request.UriPath;
			if (string.IsNullOrEmpty(requestUri))
			{
				throw new WebRpcException("The path of the request is null or empty.");
			}

			// Append parameters, if any.
			Dictionary<string, string> urlParams = Serializer.Serialize<Dictionary<string, string>>(request, urlDefinition);
			if (urlParams != null)
			{
				requestUri = URLUtilities.BuildUrlQuery(requestUri, urlParams);
			}

			return requestUri;
		}

		/// <summary>
		/// Generates the POST-body data of the request.
		/// </summary>
		/// <param name="request">The request to be sent.</param>
		/// <returns>The serialized parameters for the request.</returns>
		private Dictionary<string, object> GenerateRequestBody(IWebRpcRequest request)
		{
			request.ThrowIfNull(nameof(request));

			if (!request.GetType().IsDefined(typeof(WebRpcObjectAttribute)))
			{
				throw new WebRpcException("The request of type {0} is not marked with the required attribute of type {1}.", request.GetType().Name, typeof(WebRpcObjectAttribute).Name);
			}

			// Generate the WebRPC parameters, and if none were generated, create one.
			Dictionary<string, object> webRpcParams = Serializer.Serialize<Dictionary<string, object>>(request, bodyDefinition);
			if (webRpcParams == null)
			{
				webRpcParams = new Dictionary<string, object>(1);   // At least one, because the request ID will be appended still.
			}

			return webRpcParams;
		}

		/// <summary>
		/// Send a WebRPC operation through Photon. Since not all features are exposed through the
		/// Photon API, a custom send operation is created that applies missing features (e.g. encryption).
		/// </summary>
		/// <param name="request">The request to be sent.</param>
		/// <param name="uri">The request to be sent.</param>
		/// <param name="webRpcParams">The request to be sent.</param>
		/// <returns>A message handle when the request was delivered successfully to the Photon network.</returns>
		private WebRpcMessageHandle CustomOpWebRPC(IWebRpcRequest request, string uri, Dictionary<string, object> webRpcParams)
		{
			request.ThrowIfNull(nameof(request));
			webRpcParams.ThrowIfNull(nameof(webRpcParams));
			uri.ThrowIfNullOrWhitespace(nameof(uri));

			// Generate the request ID to identify the response.
			string requestID = GenerateRequestID();
			webRpcParams[requestID] = requestID;

			Dictionary<byte, object> opParameters = new Dictionary<byte, object>();
			opParameters.Add(ParameterCode.UriPath, uri);
			opParameters.Add(ParameterCode.WebRpcParameters, webRpcParams);

			if (request.UseAuthCookie)
			{
				opParameters.Add(ParameterCode.EventForward, WebFlags.SendAuthCookieConst);
			}

			SendOptions options = SendOptions.SendReliable;
			options.Encrypt = request.UseEncryption;
			if (photonClient.LoadBalancingPeer.SendOperation(OperationCode.WebRpc, opParameters, options))
			{
				WebRpcMessageHandle messageHandle = new WebRpcMessageHandle(request, requestID);
				AddPendingRequest(messageHandle);
				return messageHandle;
			}
			else
			{
				throw new WebRpcException("Failed to send request of type {0} to {1}.", request.GetType().Name, request.UriPath);
			}
		}

		/// <summary>
		/// Generates a request ID based on the first 8 characters of a GUID.
		/// </summary>
		/// <returns>A unique ID with respect to any pending call registered in this messenger.</returns>
		private string GenerateRequestID()
		{
			// Based on the shortid library from bolorundurowb.
			// https://github.com/bolorundurowb/shortid
			char[] requestIDChars = new char[generatedIDLength];

			for (int i = 0; i < generatedIDLength; ++i)
			{
				requestIDChars[i] = IDGenerationPool[UnityEngine.Random.Range(0, IDGenerationPool.Length)];
			}

			return new string(requestIDChars);
		}

		/// <inheritdoc />
		void IWebRpcCallback.OnWebRpcResponse(OperationResponse rawResponse)
		{
			switch (rawResponse.ReturnCode)
			{
				case -2:
					Log.Error("A WebRPC call failed. Is the Photon application configured correctly?\n{0}", rawResponse.DebugMessage);
					return;
				case 32745:
					Log.Error("A WebRPC call failed. Too many requests/second are being sent out.\n{0}", rawResponse.DebugMessage);
					return;
				case 32744:
					Log.Error("A WebRPC call failed. Something went wrong on the web service.\n{0}", rawResponse.DebugMessage);
					return;
			}

			WebRpcResponse webRpcResponse = new WebRpcResponse(rawResponse);

			// Check whether the response ID can be found and matched to a pending call.
			if ((webRpcResponse.Parameters == null) ||
				!webRpcResponse.Parameters.ContainsKey(ResponseIDKey) ||
				!(webRpcResponse.Parameters[ResponseIDKey] is string responseID) ||
				!IsPending(responseID))
			{
				return;
			}

			WebRpcMessageHandle handle = pendingCalls[responseID];
			RemovePendingRequest(handle);

			IWebRpcResponse response = InstantiateResponse(handle);
			Serializer.Deserialize(response, webRpcResponse.Parameters, bodyDefinition);
			handle.SetResponse(response, webRpcResponse.Message);

			if (handle.Response.IsSuccess)
			{
				HandleCompleted(handle);
			}
			else
			{
				HandleFailed(handle);
			}
		}
	}
}
