namespace ImpossibleOdds.Photon.WebRpc
{
	using System;
	using System.Collections.Generic;
	using ImpossibleOdds.Http;
	using ImpossibleOdds.Weblink;
	using ImpossibleOdds.Serialization;
	using global::Photon.Realtime;
	using ExitGames.Client.Photon;

	/// <summary>
	/// A messenger for WebRPC calls sent over the Photon multiplayer package.
	/// Implements the IWebRpcCallback interface so that it can be registered in the Photon callback targets.
	/// </summary>
	public class WebRpcMessenger :
		WeblinkMessenger<IWebRpcRequest, IWebRpcResponse, WebRpcMessageHandle, WebRpcResponseTypeAttribute, WebRpcResponseCallbackAttribute>,
		IWebRpcCallback,
		IDisposable
	{
		public const ushort DefaultIDLength = 8;
		public const string DefaultRequestIDKey = "RequestId";
		public const string DefaultResponseIDKey = "ResponseId";
		private const string IDGenerationPool = "ABCDEFGHIJKLMNPQRSTUVWXYabcdefghjklmnopqrstuvwxyz0123456789_-";

		private readonly static WebRpcBodySerializationDefinition bodyDefinition = new WebRpcBodySerializationDefinition();
		private readonly static WebRpcURLSerializationDefinition urlDefinition = new WebRpcURLSerializationDefinition();
		private readonly LoadBalancingClient photonClient = null;

		private ushort generatedIDLength = DefaultIDLength;
		private string requestIDKey = DefaultRequestIDKey;
		private string responseIDKey = DefaultResponseIDKey;
		private Dictionary<string, WebRpcMessageHandle> pendingCalls = new Dictionary<string, WebRpcMessageHandle>();

		/// <summary>
		/// The key of the Request ID that gets added to each outgoing WebRPC call to match incoming responses.
		/// </summary>
		public string RequestIDKey
		{
			get { return requestIDKey; }
			set
			{
				value.ThrowIfNullOrWhitespace(nameof(value));

				if ((pendingCalls.Count > 0) && (value != requestIDKey))
				{
					Log.Warning("A different name for the request ID key is being set while there are still pending calls. Incoming responses for the remaining pending calls will not be matched anymore. These will be cancelled.");
					StopAll();
				}

				requestIDKey = value;
			}
		}

		/// <summary>
		/// The key of the Response ID that should be set by the server for each response.
		/// </summary>
		public string ResponseIDKey
		{
			get { return responseIDKey; }
			set
			{
				value.ThrowIfNullOrWhitespace(nameof(value));

				if ((pendingCalls.Count > 0) && (value != responseIDKey))
				{
					Log.Warning("A different name for the response ID key is being set while there are still pending calls. Incoming responses for the remaining pending calls will not be matched anymore. These will be cancelled.");
					StopAll();
				}

				responseIDKey = value;
			}
		}

		/// <summary>
		/// The length of the IDs generated by the messenger.
		/// </summary>
		public ushort GeneratedIDLength
		{
			get { return generatedIDLength; }
			set
			{
				if (value < DefaultIDLength)
				{
					throw new ArgumentOutOfRangeException(string.Format("The length of IDs should at least be {0} long as to prevent collision.", DefaultIDLength));
				}

				generatedIDLength = value;
			}
		}

		public WebRpcMessenger(LoadBalancingClient photonClient)
		{
			photonClient.ThrowIfNull(nameof(photonClient));
			this.photonClient = photonClient;
			photonClient.AddCallbackTarget(this);
		}

		/// <summary>
		/// Clears the messenger from the photon client.
		/// </summary>
		public void Dispose()
		{
			photonClient.RemoveCallbackTarget(this);
		}

		/// <inheritdoc />
		public override WebRpcMessageHandle SendRequest(IWebRpcRequest request)
		{
			request.ThrowIfNull(nameof(request));

			if (!photonClient.IsConnectedAndReady)
			{
				throw new WebRpcException("Photon isn't connected. Cannot send out any requests.");
			}

			// If the request is already pending, just return the existing handle.
			if (IsPending(request))
			{
				return GetMessageHandle(request);
			}

			string requestID = GenerateRequestID();
			if (CustomOpWebRPC(request, requestID))
			{
				WebRpcMessageHandle messageHandle = new WebRpcMessageHandle(request, requestID);
				AddPendingRequest(messageHandle);
				return messageHandle;
			}
			else
			{
				throw new WebRpcException("Failed to send request of type {0} to {1}.", request.GetType().Name, request.UriPath);
			}
		}

		/// <inheritdoc />
		public override void StopAll()
		{
			base.StopAll();
			pendingCalls.Clear();
		}

		/// <summary>
		/// Stops a pending request with the given ID.
		/// </summary>
		/// <param name="requestID">The ID of the request to stop.</param>
		public void Stop(string requestID)
		{
			requestID.ThrowIfNullOrWhitespace(nameof(requestID));

			if (IsPending(requestID))
			{
				RemovePendingRequest(pendingCalls[requestID]);
			}
		}

		/// <summary>
		/// Check whether a request with the given request ID is pending a response.
		/// </summary>
		/// <param name="requestID">The ID of the request to check for.</param>
		/// <returns>True if such a request is pending. False otherwise.</returns>
		public bool IsPending(string requestID)
		{
			requestID.ThrowIfNullOrWhitespace(nameof(requestID));
			return pendingCalls.ContainsKey(requestID);
		}

		/// <inheritdoc />
		protected override void AddPendingRequest(WebRpcMessageHandle handle)
		{
			handle.ThrowIfNull(nameof(handle));

			base.AddPendingRequest(handle);
			pendingCalls[handle.RequestID] = handle;
		}

		/// <inheritdoc />
		protected override void RemovePendingRequest(IWebRpcRequest request)
		{
			request.ThrowIfNull(nameof(request));

			if (IsPending(request))
			{
				WebRpcMessageHandle handle = GetMessageHandle(request);
				pendingCalls.Remove(handle.RequestID);
			}

			base.RemovePendingRequest(request);
		}

		/// <summary>
		/// Send a WebRPC operation through Photon. Since not all features are exposed through the
		/// Photon API, a custom send operation is created that applies missing features (e.g. encryption).
		/// </summary>
		/// <param name="request">The request to be sent.</param>
		/// <param name="requestID">The request ID assigned in this messenger.</param>
		/// <returns>True if the request was enqueued for sending in Photon, false otherwise.</returns>
		private bool CustomOpWebRPC(IWebRpcRequest request, string requestID)
		{
			requestID.ThrowIfNullOrWhitespace(nameof(requestID));

			string requestUri = request.UriPath;
			requestUri.ThrowIfNullOrWhitespace(nameof(requestUri));

			Dictionary<string, string> urlParams = Serializer.Serialize<Dictionary<string, string>>(request, urlDefinition);
			if (urlParams != null)
			{
				requestUri = URLUtilities.BuildUrlQuery(requestUri, urlParams);
			}

			Dictionary<string, object> webRpcParams = Serializer.Serialize<Dictionary<string, object>>(request, bodyDefinition);
			if (webRpcParams == null)
			{
				throw new WebRpcException("The WebRPC parameters object is expected to be of type {0}. Have you tagged your request with the {1} attribute?", typeof(Dictionary<string, object>).Name, typeof(WebRpcObjectAttribute).Name);
			}

			// Add the request ID to the parameters.
			webRpcParams[RequestIDKey] = requestID;

			Dictionary<byte, object> opParameters = new Dictionary<byte, object>();
			opParameters.Add(ParameterCode.UriPath, requestUri);
			opParameters.Add(ParameterCode.WebRpcParameters, webRpcParams);

			if (request.UseAuthCookie)
			{
				opParameters.Add(ParameterCode.EventForward, WebFlags.SendAuthCookieConst);
			}

			SendOptions options = SendOptions.SendReliable;
			options.Encrypt = request.UseEncryption;
			return photonClient.LoadBalancingPeer.SendOperation(OperationCode.WebRpc, opParameters, options);
		}

		/// <summary>
		/// Generates a request ID based on the first 8 characters of a GUID.
		/// </summary>
		/// <returns>A unique ID with respect to any pending call registered in this messenger.</returns>
		private string GenerateRequestID()
		{
			// Based on the shortid library from bolorundurowb.
			// https://github.com/bolorundurowb/shortid
			char[] requestIDChars = new char[generatedIDLength];

			for (int i = 0; i < generatedIDLength; ++i)
			{
				requestIDChars[i] = IDGenerationPool[UnityEngine.Random.Range(0, IDGenerationPool.Length)];
			}

			return new string(requestIDChars);
		}

		/// <inheritdoc />
		void IWebRpcCallback.OnWebRpcResponse(OperationResponse rawResponse)
		{
			switch (rawResponse.ReturnCode)
			{
				case -2:
					Log.Error("A WebRPC call failed. Is the Photon application configured correctly?\n{0}", rawResponse.DebugMessage);
					return;
				case 32745:
					Log.Error("A WebRPC call failed. Too many requests/second are being sent out.\n{0}", rawResponse.DebugMessage);
					return;
				case 32744:
					Log.Error("A WebRPC call failed. Something went wrong on the web service.\n{0}", rawResponse.DebugMessage);
					return;
			}

			WebRpcResponse webRpcResponse = new WebRpcResponse(rawResponse);

			// Check whether the response ID can be found and matched to a pending call.
			if ((webRpcResponse.Parameters == null) ||
				!webRpcResponse.Parameters.ContainsKey(ResponseIDKey) ||
				!(webRpcResponse.Parameters[ResponseIDKey] is string responseID) ||
				!IsPending(responseID))
			{
				return;
			}

			WebRpcMessageHandle handle = pendingCalls[responseID];
			RemovePendingRequest(handle);

			IWebRpcResponse response = InstantiateResponse(handle);
			Serializer.Deserialize(response, webRpcResponse.Parameters, bodyDefinition);
			handle.SetResponse(response, webRpcResponse.Message);

			if (handle.Response.IsSuccess)
			{
				HandleCompleted(handle);
			}
			else
			{
				HandleFailed(handle);
			}
		}
	}
}
