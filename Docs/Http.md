# ![Impossible Odds Logo][Logo] Unity C# Toolkit - HTTP

The HTTP tools described below are accessed by including the `ImpossibleOdds.Http` namespace in your scripts.

When you want to communicate with a server you can use Unity's built-in `UnityWebRequest` class. This can be pretty convenient to host leaderboards, record player progression, or download content or other resources. The `UnityWebRequest` class allows you to setup custom HTTP calls of any kind. One drawback is their setup, which can be cumbersome depending on the amount and complexity of parameters involved.

To relieve you from the manual labour of setting up these requests, the tools in this framework can do much of the heavy lifting. Next to that, there's a messenger system that takes care of sending your request, processing icoming responses and notifying you when something got in.

Here's a quick overview of what you can expect of this HTTP framework:

* Generate `UnityWebRequest`-compatible data structures out of your objects.
* Process incoming responses automatically based on the requests that were sent out.
* A variety of ways on getting notified when a response is received.

**Note**: A prerequisite for using this tool is, of course, that you have an actual server running that you can send requests to, and that will return you some valid data.

## Requests

A request, in this context, is the message you send to your server. It contains the data or parameters about what you wan the server to do, be it updating a leaderboard, download an image, or something else.

There are several types of HTTP requests that you can make. Each type has a different meaning to the server as well how you define the parameters for what you want to do with it. The following types of HTTP requests are supported in helping you pack your objects into custom requests:

* GET requests to retrieve information or download larger pieces of data.
* POST requests to send structured data such as a filled in form by the user.
* PUT requests to upload larger packs of data such as images or other files.

So before you start creating your custom request, try to define which type of request they should be. Each type of request should implement the `IHttpRequest` interface though. It's the base interface that is required by each request being process by this framework. There are several variants of this interface defined for each of the type of requests described above.

### URL & Headers

All types of requests share some common properties: they require a URL (the address to send the request to) with optionally some URL parameters and headers. The URL of your request is a required property that needs to be implemented through the `URL` property.

```cs
public class MyRequest : IHttpRequest
{
	public string URL
	{
		get { return "example.com/myrequest"; }
	}
}
```

Typically, a URL can also contain parameters. To add a parameter to the URL, use the `HttpUrlField` attribute on the fields of your request class. You can provide an optional name to be used as the parameter name. When left empty, the name of the field is used.

In the `URL` property you are expected to return the base address for the request, which will get appended with the generated parameters. However, you can safely define parameters already in this URL address string if you like. The framework will take care of properly appending the generated parameters, if any.

Less common is to define extra headers, but is sometimes necessary nonetheless. This can be done by using the `HttpHeaderField` attribute in much the same way as you would do for URL parameters. They are limited to primitive or basic types. You can define an optional parameter name for the field. For more information about HTTP headers, please read up at [this documentation page](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers).

```cs
public class MyRequest : IHttpRequest
{
	// Returns the base URL.
	public string URL
	{
		get { return "example.com/myrequest"; }
	}

	// Parameters to be added to the URL.
	[HttpUrlField]
	private string name = "ImpossibleOdds";
	[HttpUrlField]
	private int age = 30;

	// Parameters to be added to the headers of the request.
	[HttpHeaderField("gameservice")]
	private string platform = "Steam";
}
```

The above example would generate a URL to `example.com/myrequest?name=ImpossibleOdds&age=30` with a custom header value in there called `gameservice`. The URL parameters generated by defining them with the `HttpUrlField` attribute are properly escaped before appending them.

### GET Requests

GET requests mainly exist to ask the server to fetch resources, e.g. a leaderboard, an image or something else.

To have your request class be picked up by the framework as a GET request, simply implement the `IHttpGetRequest`. It doesn't require you to actually implement anything extra. It simply denotes your class as such. Its parameters are defined through its URL though, so anything extra that defines the request should be added using the `HttpUrlField` attribute as seen in the [URL & Headers section](#url-&-headers)

```cs
public class MyRequest : IHttpGetRequest
{
	public string URL
	{
		get { return "example.com/myrequest"; }
	}

	// Parameters to be added to the URL.
	[HttpUrlField]
	private string name = "ImpossibleOdds";
	[HttpUrlField]
	private int age = 30;
}
```

However, there are several kinds of GET request templates available already to you, primarily based on what Unity's framework already supports out of the box:

* The `IHttpGetAudioClipRequest` interface to set up a request to download an audio clip. Additionally, you must provide what kind of audio clip it will by implementing the mandatory `AudioType` property.
* The `IHttpGetTextureRequest` interface to download a texture.
* The `IHttpGetAssetBundleRequest` interface can be used to download an asset bundle.

### POST Requests

A POST request serves to send over some structured data to the server and do something with it, e.g. a registration form, or updating a score on a leaderboard. It's not designed to send over big chunks of data like images, video or other forms of binary data. Please check out the topic about [PUT requests](#put-requests) to upload bigger sets of data.

To have your object be recognised as a POST request by this framework, have it implement the `IHttpPostRequest` interface. This interface on its own does not force any additional properties or methods to be implemented but does allow you to define a complex set of parameters that will be set in the request's body.

In essence it tries to deconstruct the inner datastructures to something that is easily processable. Two datastructures come to mind:

* A lookup table where a variable is identified by a name, e.g. a dictionary, and
* A list where variables are inserted based on an index value.

This way, your object can contain nested parameters which in turn can be a complex set of data again. To define which kind of data structure is preferred for a class that can be processed by the framework, you can rely on these attributes:

* The `HttpBodyObject` attribute to process your object as a lookup table and is assisted by the `HttpBodyField` attribute, which can define an optional alternative name for the field.
* The `HttpBodyArry` attributes to process your object as an array and is assisted by the `HttpBodyIndex` attribute to define the index of a field in this list.

**Note**: your POST request class itself should also be marked with either a `HttpBodyObject` or `HttpBodyArray` attribute as this object functions as the root for the parameters.

```cs
// Object that should get processed as an array.
[HttpBodyArray]
public class CheckpointData
{
	[HttpBodyIndex(0)]
	private string checkpointID;
	[HttpBodyIndex(1)]
	private float time;
}

// Process the request's data as an object.
[HttpBodyObject]
public class MyRequest : IHttpPostRequest
{
	public string URL
	{
		get;
	}

	[HttpBodyField]
	private string leaderboardID;
	[HttpBodyField]
	private int userID;
	[HttpBodyField]
	private float raceTime;
	[HttpBodyField]
	private float[] lapTimes;
	[HttpBodyField("checkpoints")]
	private List<CheckpointData> checkpointData;
}
```

An example output of this data placed in the body of the request could be:

```json
{
	"leaderboardID": "f6675658-6a60-4fc2-9b49-412a6fd88165",
	"userID": 101,
	"raceTime": 420.69,
	"laptimes": [
		143.23,
		140.23
		137.23,
	],
	"checkpoints": [
		[
			"06747de7",
			64.47
		],
		[
			"63ac",
			88.51
		]
	]
}
```

### PUT Requests

To upload larger pieces of data on a server you typically use PUT requests. They can be used to send over data 'as is', without additional processing, at least not from this framework.

To setup a PUT request, either implement the `IHttpPutStringRequest` or `IHttpPutBinaryRequest` interface. These define the two supported types of data you want to transmit: string or binary data respectively. This defines how the server should interpret the received data.

Both of these interface require to implement the `PutData` property. Depending on which PUT interface variant you implement, it either requires it to return a `string` value or a `byte[]` value.

```cs
// Set up a request to send over text data from a file.
public class MyStringPutRequest : IHttpPutStringRequest
{
	public string URL
	{
		get;
	}

	public string PutData
	{
		get { return File.ReadAllText("configuration.xml"); }
	}
}

// Set up a request to send over binary data from a file.
public class MyBinaryPutRequest : IHttpPutBinaryRequest
{
	public string URL
	{
		get;
	}

	public byte[] PutData
	{
		get { return File.ReadAllBytes("banner.png");}
	}
}
```

**Note**: not all HTTP servers allow PUT requests to come through and may require additional action to enable it.

## Responses

When your server decides to send something back, this framework can immediately processes the incoming data to usable objects. Based on the type of request you sent out, you can also define what kind of response to expect back.

To associate a request with a particular response type, you must decorate you **request** class with an `HttpResponseType` attribute. A request can only be associated with a single type of response.

```cs
// Associate the request type with a response type.
[HttpResponseType(typeof(MyResponse))]
public class MyRequest : IHttpRequest
{
	public string URL
	{
		get;
	}
}

public class MyResponse : IHttpResponse
{ }
```

To have the server's response be processed automatically, have your response object implement one of the following interfaces. If you don't define any, then it's entirely up to you to deal with the response data later.

* The `IHttpJsonResponse` interface defines that the expected response data is JSON formatted data.
* The `IHttpCustomResponse` interface for other kinds of data that might need your attention, such as compressed/zipped data that needs decompression, decoded, etc.
* The `IHttpAudioClipResponse` interface expects the response to be an audio clip. This works in combination with `IHttpAudioClipRequest`. See the [GET Requests section](#get-requests).
* The `IHttpTextureResponse` interface expects the response to be a texture. This works in combination with `IHttpTextureRequest`. See the [GET Requests section](#get-requests).
* The `IHttpAssetBundleResponse` interface expects the response to be an asset bundle. This works in combination with `IHttpAssetBundleRequest`. See the [GET Requests section](#get-requests).

Whichever of the above your response implements, the result is only processed when the request didn't encounter a network or server error.

### JSON Responses

If you expect the server to return data in the form of a JSON string, you can have your response object implement the `IHttpJsonResponse` interface. This works in exactly the same way as the [POST request](#post-requests) setup.

By using the `HttpBodyObject` and `HttpBodyArray` attributes on the objects that could be included by the response and defining their fields with the `HttpBodyField` and `HttpBodyIndex` attributes respectively, the response data is unwrapped and processed directly for use.

**Note**: the response object itself should also be marked with either a `HttpBodyObject` or `HttpBodyArray` attribute as it serves as the root for the unwrapping of the response.

```cs
[HttpBodyArray]
public class LeaderboardEntry
{
	[HttpBodyIndex(0)]
	private int userID;
	[HttpBodyIndex(1)]
	private float score;
}

[HttpBodyObject]
public class Leaderboard
{
	[HttpBodyField("ID")]
	private string leaderboardID;
	[HttpBodyField]
	private DateTime lastUpdated;
	[HttpBodyField]
	private List<LeaderboardEntry> entries;
}

[HttpBodyObject]
public class MyJsonResponse : IHttpJsonResponse
{
	[HttpBodyField]
	private Leaderboard leaderboard;
}
```

This kind of response is perfect for processing responses from GET or POST requests which return structured data.

### Custom Response Handlers

When your response implements the `IHttpCustomResponse` interface, it expects you to process the response further. This might be necessary in case you need to unpack or decrypt the returned data. The `ProcessResponse` method will get called on your response object along with the `UnityWebRequest` that is associated with it.

```cs
public class MyCustomResponse : IHttpCustomResponse
{
	public void ProcessResponse(UnityWebRequest request)
	{
		// Process the data
	}
}
```

## Messenger

Up until now you've seen what needs to be done on your request and response objects for them to be processed automatically. However, that doesn't happen on its own though. The `HttpMessenger` class takes care of that.

Whenever you want to send a request, provide your custom request object by using its `SendRequest` method and it will take care of everything. All that remains is to sit back and wait for a reply to come back.

```cs
MyRequest request;	// Implements one of the IHttpRequest interfaces.
HttpMessenger messenger = new HttpMessenger();	// Can be re-used for multiple requests at a time.
messenger.SendRequest(request);
```

The messenger also allows you to subscribe to events that will trigger the moment a request completes or fails. This way you can get notified when a request completes (or fails).

```cs
MyRequest request;
HttpMessenger messenger = new HttpMessenger();
messenger.onMessageCompleted += OnMessageCompleted;
messenger.onMessageFailed += OnMessageFailed;
messenger.SendRequest(request);

private void OnMessageCompleted(HttpMessageHandle messageHandle)
{
	// Check the response.
	IHttpResponse response = messageHandle.Response;
}

private void OnMessageFailed(HttpMessageHandle messageHandle)
{
	// Check why the message failed.
	if (messageHandle.WebRequest.isNetworkError)
	{
		// A network error occurred.
	}
	else if (messageHandle.WebRequest.isHttpError)
	{
		// An HTTP error occurred.
	}
}
```

### Message Handles

Whenever you send a request through an `HttpMessenger`, it will return you a _message handle_. This handle allows you to check up on the progress of your request, including whether it encountered an error. This handle is also yieldable, so you can wait for it to complete in a coroutine.

```cs
private HttpMessenger messenger = new HttpMessenger();

private IEnumerator RoutineHandleMessage(IHttpRequest request)
{
	HttpMessageHandle messageHandle = messenger.SendRequest(request);

	// Wait for it to complete.
	yield return messageHandle;

	if (messageHandle.IsError)
	{
		// Handle error.
		yield break;
	}
	else if (messageHandle.IsDone)
	{
		// Get the response and process it.
		IHttpResponse response = messageHandle.Response;
	}
}
```

The handle also allows you to work with the actual instance of the `UnityWebRequest` as well through its `WebRequest` property. This way you can check up on any download progress of resources, or see what kind of error happened exactly.

### Callbacks

Another way to get notified is by registering your object to the messenger's callback mechanism. The advantage of using one of these callbacks over subscribing to events or using the message handle is that you can define methods that are interested when a particular type of response is received, as well as getting access directly to the fully qualified type-casted request and received response. This saves you time of trying to figure out what exactly came in.

A method is marked as a callback by placing the `HttpResponseCallback` attribute over the method. It takes the type of a _response_, which defines for which responses it will be called.

Finally, this object should still get registered at the messenger that it is interested in receiving callbacks.

```cs
// Object that is capable of handling response of type MyResponse.
public class MyMessageHandler
{
	[HttpResponseCallback(typeof(MyResponse))]
	private void OnMyResponseReceived(HttpMessageHandle handle, MyRequest request, MyResponse response)
	{
		// Check the state of the handle and the response.
	}
}

// Create a custom message handler and register it with the messenger.
MyRequest request;
MyMessageHandler messageHandler = new MyMessageHandler();
HttpMessenger messenger = new HttpMessenger();
messenger.RegisterCallback(messageHandler);
messenger.SendRequest(request);
```

For these callbacks, the parameters can be in any order and every parameter is optional. So feel free to leave out any that you don't need from the parameter list. There are also not special restrictions imposed on the callback object in terms of interfaces or derived types. It can be just any kind of object.

## Example

Check out the HTTP sample scene for a hands-on example!

[Logo]: ./Images/ImpossibleOddsLogo.png
[JSON]: ./Json.md
